import { TarefaCronograma, CategoriaCronograma } from '../types/cronograma';

export interface AIInsight {
  id: string;
  tipo: 'crÃ­tico' | 'atenÃ§Ã£o' | 'oportunidade' | 'sucesso';
  tÃ­tulo: string;
  descriÃ§Ã£o: string;
  impacto: 'alto' | 'mÃ©dio' | 'baixo';
  recomendaÃ§Ãµes: string[];
  mÃ©tricas?: {
    valor: number;
    unidade: string;
    tendÃªncia: 'subindo' | 'descendo' | 'estÃ¡vel';
  };
  categoria: string;
}

export interface AIAnalysisResult {
  insights: AIInsight[];
  resumo: {
    statusGeral: 'crÃ­tico' | 'atenÃ§Ã£o' | 'normal' | 'excelente';
    progressoEsperado: number;
    progressoReal: number;
    diasAtraso: number;
    riscoProjeto: number; // 0-100
  };
  aÃ§ÃµesRecomendadas: {
    prioridade: 'alta' | 'mÃ©dia' | 'baixa';
    aÃ§Ã£o: string;
    prazo: string;
    responsÃ¡vel: string;
  }[];
}

export class AIInsightsService {
  private static instance: AIInsightsService;

  public static getInstance(): AIInsightsService {
    if (!AIInsightsService.instance) {
      AIInsightsService.instance = new AIInsightsService();
    }
    return AIInsightsService.instance;
  }

  /**
   * AnÃ¡lise principal que processa todos os dados do projeto PFUS3
   */
  public analisarProjeto(categorias: CategoriaCronograma[]): AIAnalysisResult {
    const hoje = new Date('2025-08-17'); // Data atual
    const inicioBaseline = new Date('2025-05-31'); // InÃ­cio PFUS3
    const fimBaseline = new Date('2025-08-14'); // Fim baseline PFUS3

    console.log('ðŸ¤– IA iniciando anÃ¡lise do projeto PFUS3...');

    const todasTarefas = this.extrairTodasTarefas(categorias);
    const insights: AIInsight[] = [];

    // AnÃ¡lise temporal do projeto
    const analiseTemporalResult = this.analiseTemporal(
      todasTarefas,
      hoje,
      inicioBaseline,
      fimBaseline
    );
    insights.push(...analiseTemporalResult.insights);

    // AnÃ¡lise de performance por categoria
    const analisePerformanceResult = this.analisePerformanceCategorias(
      categorias,
      hoje
    );
    insights.push(...analisePerformanceResult.insights);

    // AnÃ¡lise de riscos crÃ­ticos
    const analiseRiscosResult = this.analiseRiscosCriticos(todasTarefas, hoje);
    insights.push(...analiseRiscosResult.insights);

    // AnÃ¡lise de dependÃªncias e gargalos
    const analiseDependenciasResult =
      this.analiseDependenciasGargalos(todasTarefas);
    insights.push(...analiseDependenciasResult.insights);

    // AnÃ¡lise de eficiÃªncia e produtividade
    const analiseEficienciaResult = this.analiseEficienciaProdutividade(
      todasTarefas,
      hoje
    );
    insights.push(...analiseEficienciaResult.insights);

    // Calcular resumo geral
    const resumo = this.calcularResumoGeral(todasTarefas, hoje, fimBaseline);

    // Gerar aÃ§Ãµes recomendadas baseadas nos insights
    const aÃ§ÃµesRecomendadas = this.gerarAÃ§ÃµesRecomendadas(insights, resumo);

    console.log(
      'ðŸ¤– IA finalizou anÃ¡lise - Encontrados',
      insights.length,
      'insights'
    );

    return {
      insights: insights.sort(
        (a, b) =>
          this.getPrioridadeNumerica(a.impacto) -
          this.getPrioridadeNumerica(b.impacto)
      ),
      resumo,
      aÃ§ÃµesRecomendadas,
    };
  }

  private extrairTodasTarefas(
    categorias: CategoriaCronograma[]
  ): TarefaCronograma[] {
    const todas: TarefaCronograma[] = [];
    categorias.forEach((categoria) => {
      if (categoria.tarefas) {
        categoria.tarefas.forEach((tarefa) => {
          todas.push(tarefa);
          if (tarefa.subatividades) {
            todas.push(...tarefa.subatividades);
          }
        });
      }
    });
    return todas;
  }

  private analiseTemporal(
    tarefas: TarefaCronograma[],
    hoje: Date,
    inicioBaseline: Date,
    fimBaseline: Date
  ) {
    const insights: AIInsight[] = [];

    // AnÃ¡lise de atraso do projeto
    const diasAposBaseline = Math.ceil(
      (hoje.getTime() - fimBaseline.getTime()) / (1000 * 60 * 60 * 24)
    );

    if (diasAposBaseline > 0) {
      insights.push({
        id: 'atraso-projeto',
        tipo: 'crÃ­tico',
        tÃ­tulo: 'Projeto PFUS3 em Atraso CrÃ­tico',
        descriÃ§Ã£o: `O projeto ultrapassou a data baseline em ${diasAposBaseline} dias. A parada deveria ter sido concluÃ­da em 14/08/2025.`,
        impacto: 'alto',
        categoria: 'Cronograma',
        recomendaÃ§Ãµes: [
          'Acelerar atividades crÃ­ticas restantes',
          'Revisar escopo para priorizar itens essenciais',
          'Aumentar recursos nas equipes crÃ­ticas',
          'Implementar trabalho em turnos estendidos',
        ],
        mÃ©tricas: {
          valor: diasAposBaseline,
          unidade: 'dias',
          tendÃªncia: 'subindo',
        },
      });
    }

    // AnÃ¡lise de progresso vs tempo esperado
    const tempoTotalBaseline =
      (fimBaseline.getTime() - inicioBaseline.getTime()) /
      (1000 * 60 * 60 * 24);
    const tempoDecorrido =
      (hoje.getTime() - inicioBaseline.getTime()) / (1000 * 60 * 60 * 24);
    const progressoEsperado = Math.min(
      100,
      (tempoDecorrido / tempoTotalBaseline) * 100
    );

    const progressoReal =
      tarefas.reduce((acc, t) => acc + t.percentualCompleto, 0) /
      tarefas.length;
    const desvioProgresso = progressoReal - progressoEsperado;

    if (desvioProgresso < -20) {
      insights.push({
        id: 'progresso-atrasado',
        tipo: 'crÃ­tico',
        tÃ­tulo: 'Progresso Significativamente Abaixo do Esperado',
        descriÃ§Ã£o: `Progresso real (${progressoReal.toFixed(1)}%) estÃ¡ ${Math.abs(desvioProgresso).toFixed(1)}% abaixo do esperado (${progressoEsperado.toFixed(1)}%).`,
        impacto: 'alto',
        categoria: 'Performance',
        recomendaÃ§Ãµes: [
          'Revisar metodologia de execuÃ§Ã£o',
          'Identificar e remover impedimentos',
          'Realocar recursos para atividades atrasadas',
          'Implementar reuniÃµes diÃ¡rias de acompanhamento',
        ],
      });
    }

    return { insights };
  }

  private analisePerformanceCategorias(
    categorias: CategoriaCronograma[],
    hoje: Date
  ) {
    const insights: AIInsight[] = [];

    const performanceCateg = categorias
      .map((cat) => {
        const tarefas = cat.tarefas || [];
        const progressoMedio =
          tarefas.reduce((acc, t) => acc + t.percentualCompleto, 0) /
          Math.max(tarefas.length, 1);
        const tarefasAtrasadas = tarefas.filter((t) => {
          const fim = new Date(t.fim);
          return fim < hoje && t.percentualCompleto < 100;
        }).length;

        return {
          nome: cat.nome,
          progresso: progressoMedio,
          tarefasAtrasadas,
          totalTarefas: tarefas.length,
          eficiencia: tarefasAtrasadas / Math.max(tarefas.length, 1),
        };
      })
      .filter((c) => c.totalTarefas > 0);

    // Identificar categoria com pior performance
    const piorCategoria = performanceCateg.reduce((a, b) =>
      a.eficiencia > b.eficiencia ? a : b
    );

    if (piorCategoria.eficiencia > 0.3) {
      // Mais de 30% das tarefas atrasadas
      insights.push({
        id: 'categoria-problematica',
        tipo: 'crÃ­tico',
        tÃ­tulo: `Categoria "${piorCategoria.nome}" com Performance CrÃ­tica`,
        descriÃ§Ã£o: `${piorCategoria.tarefasAtrasadas} de ${piorCategoria.totalTarefas} tarefas estÃ£o atrasadas (${(piorCategoria.eficiencia * 100).toFixed(1)}%).`,
        impacto: 'alto',
        categoria: piorCategoria.nome,
        recomendaÃ§Ãµes: [
          `ReforÃ§ar equipe de ${piorCategoria.nome}`,
          'Revisar metodologia especÃ­fica desta categoria',
          'Implementar supervisÃ£o dedicada',
          'Verificar disponibilidade de materiais/equipamentos',
        ],
      });
    }

    // Identificar categoria com melhor performance
    const melhorCategoria = performanceCateg.reduce((a, b) =>
      a.progresso > b.progresso ? a : b
    );

    if (melhorCategoria.progresso > 80) {
      insights.push({
        id: 'categoria-excelente',
        tipo: 'sucesso',
        tÃ­tulo: `Categoria "${melhorCategoria.nome}" com Excelente Performance`,
        descriÃ§Ã£o: `Progresso de ${melhorCategoria.progresso.toFixed(1)}% demonstra excelente execuÃ§Ã£o.`,
        impacto: 'mÃ©dio',
        categoria: melhorCategoria.nome,
        recomendaÃ§Ãµes: [
          'Replicar metodologia para outras categorias',
          'Documentar melhores prÃ¡ticas',
          'Considerar remanejamento de recursos experientes',
        ],
      });
    }

    return { insights };
  }

  private analiseRiscosCriticos(tarefas: TarefaCronograma[], hoje: Date) {
    const insights: AIInsight[] = [];

    // Identificar tarefas com risco iminente
    const tarefasRiscoIminente = tarefas.filter((t) => {
      const fim = new Date(t.fim);
      const diasRestantes = Math.ceil(
        (fim.getTime() - hoje.getTime()) / (1000 * 60 * 60 * 24)
      );
      return (
        diasRestantes <= 3 && diasRestantes >= 0 && t.percentualCompleto < 100
      );
    });

    if (tarefasRiscoIminente.length > 0) {
      insights.push({
        id: 'risco-iminente',
        tipo: 'crÃ­tico',
        tÃ­tulo: 'Tarefas com Prazo CrÃ­tico Iminente',
        descriÃ§Ã£o: `${tarefasRiscoIminente.length} tarefas vencem nos prÃ³ximos 3 dias e ainda nÃ£o foram concluÃ­das.`,
        impacto: 'alto',
        categoria: 'Risco',
        recomendaÃ§Ãµes: [
          'Priorizar imediatamente estas tarefas',
          'Alocar recursos extras',
          'Trabalho em regime de urgÃªncia',
          'Comunicar stakeholders sobre situaÃ§Ã£o crÃ­tica',
        ],
        mÃ©tricas: {
          valor: tarefasRiscoIminente.length,
          unidade: 'tarefas',
          tendÃªncia: 'subindo',
        },
      });
    }

    // AnÃ¡lise de tarefas estagnadas
    const tarefasEstagnadas = tarefas.filter((t) => {
      const inicio = new Date(t.inicio);
      const diasDesdeInicio = Math.ceil(
        (hoje.getTime() - inicio.getTime()) / (1000 * 60 * 60 * 24)
      );
      return diasDesdeInicio > 7 && t.percentualCompleto === 0;
    });

    if (tarefasEstagnadas.length > 0) {
      insights.push({
        id: 'tarefas-estagnadas',
        tipo: 'atenÃ§Ã£o',
        tÃ­tulo: 'Tarefas NÃ£o Iniciadas HÃ¡ Mais de 7 Dias',
        descriÃ§Ã£o: `${tarefasEstagnadas.length} tarefas deveriam ter iniciado mas permanecem em 0% de progresso.`,
        impacto: 'mÃ©dio',
        categoria: 'ExecuÃ§Ã£o',
        recomendaÃ§Ãµes: [
          'Verificar impedimentos para inÃ­cio',
          'Confirmar disponibilidade de recursos',
          'Revisar dependÃªncias e prÃ©-requisitos',
          'Estabelecer datas de inÃ­cio forÃ§adas',
        ],
      });
    }

    return { insights };
  }

  private analiseDependenciasGargalos(tarefas: TarefaCronograma[]) {
    const insights: AIInsight[] = [];

    // AnÃ¡lise de dependÃªncias complexas
    const tarefasComMuitasDependencias = tarefas.filter((t) => {
      const deps =
        t.predecessores?.split(',').filter((d) => d.trim()).length || 0;
      return deps > 3;
    });

    if (tarefasComMuitasDependencias.length > 0) {
      insights.push({
        id: 'dependencias-complexas',
        tipo: 'atenÃ§Ã£o',
        tÃ­tulo: 'Tarefas com DependÃªncias Complexas Identificadas',
        descriÃ§Ã£o: `${tarefasComMuitasDependencias.length} tarefas possuem mais de 3 dependÃªncias, aumentando risco de atrasos em cascata.`,
        impacto: 'mÃ©dio',
        categoria: 'DependÃªncias',
        recomendaÃ§Ãµes: [
          'Simplificar dependÃªncias quando possÃ­vel',
          'Monitorar closely precedentes crÃ­ticos',
          'Preparar planos de contingÃªncia',
          'Considerar execuÃ§Ã£o paralela onde viÃ¡vel',
        ],
      });
    }

    return { insights };
  }

  private analiseEficienciaProdutividade(
    tarefas: TarefaCronograma[],
    hoje: Date
  ) {
    const insights: AIInsight[] = [];

    // AnÃ¡lise de velocidade de execuÃ§Ã£o
    const tarefasEmAndamento = tarefas.filter(
      (t) => t.percentualCompleto > 0 && t.percentualCompleto < 100
    );

    let velocidadeMedia = 0;
    if (tarefasEmAndamento.length > 0) {
      velocidadeMedia =
        tarefasEmAndamento.reduce((acc, t) => {
          const inicio = new Date(t.inicio);
          const diasDesdeInicio = Math.max(
            1,
            Math.ceil(
              (hoje.getTime() - inicio.getTime()) / (1000 * 60 * 60 * 24)
            )
          );
          return acc + t.percentualCompleto / diasDesdeInicio;
        }, 0) / tarefasEmAndamento.length;
    }

    if (velocidadeMedia < 5) {
      // Menos de 5% por dia em mÃ©dia
      insights.push({
        id: 'baixa-velocidade',
        tipo: 'atenÃ§Ã£o',
        tÃ­tulo: 'Velocidade de ExecuÃ§Ã£o Abaixo do Ideal',
        descriÃ§Ã£o: `Velocidade mÃ©dia de execuÃ§Ã£o Ã© ${velocidadeMedia.toFixed(1)}%/dia, indicando possÃ­vel subutilizaÃ§Ã£o de recursos.`,
        impacto: 'mÃ©dio',
        categoria: 'Produtividade',
        recomendaÃ§Ãµes: [
          'Analisar gargalos na execuÃ§Ã£o',
          'Otimizar processos de trabalho',
          'Verificar adequaÃ§Ã£o de recursos',
          'Implementar mÃ©tricas de produtividade diÃ¡rias',
        ],
      });
    }

    return { insights };
  }

  private calcularResumoGeral(
    tarefas: TarefaCronograma[],
    hoje: Date,
    fimBaseline: Date
  ) {
    const progressoReal =
      tarefas.reduce((acc, t) => acc + t.percentualCompleto, 0) /
      tarefas.length;
    const diasAtraso = Math.max(
      0,
      Math.ceil(
        (hoje.getTime() - fimBaseline.getTime()) / (1000 * 60 * 60 * 24)
      )
    );

    const tarefasAtrasadas = tarefas.filter((t) => {
      const fim = new Date(t.fim);
      return fim < hoje && t.percentualCompleto < 100;
    }).length;

    const riscoProjeto = Math.min(
      100,
      diasAtraso * 10 +
        (tarefasAtrasadas / tarefas.length) * 50 +
        (100 - progressoReal) * 0.5
    );

    let statusGeral: 'crÃ­tico' | 'atenÃ§Ã£o' | 'normal' | 'excelente';
    if (riscoProjeto > 70) statusGeral = 'crÃ­tico';
    else if (riscoProjeto > 40) statusGeral = 'atenÃ§Ã£o';
    else if (riscoProjeto > 20) statusGeral = 'normal';
    else statusGeral = 'excelente';

    return {
      statusGeral,
      progressoEsperado: 100, // Deveria estar 100% na baseline
      progressoReal: Math.round(progressoReal),
      diasAtraso,
      riscoProjeto: Math.round(riscoProjeto),
    };
  }

  private gerarAÃ§ÃµesRecomendadas(insights: AIInsight[], resumo: any) {
    const aÃ§Ãµes: any[] = [];

    // AÃ§Ãµes baseadas no status geral
    if (resumo.statusGeral === 'crÃ­tico') {
      aÃ§Ãµes.push({
        prioridade: 'alta',
        aÃ§Ã£o: 'Implementar sala de crise para gestÃ£o de projeto',
        prazo: 'Imediato',
        responsÃ¡vel: 'Gerente de Projeto',
      });

      aÃ§Ãµes.push({
        prioridade: 'alta',
        aÃ§Ã£o: 'Revisar e otimizar cronograma com foco no crÃ­tico',
        prazo: '1 dia',
        responsÃ¡vel: 'Planejamento',
      });
    }

    // AÃ§Ãµes especÃ­ficas baseadas nos insights crÃ­ticos
    const insightsCriticos = insights.filter((i) => i.tipo === 'crÃ­tico');
    if (insightsCriticos.length > 0) {
      aÃ§Ãµes.push({
        prioridade: 'alta',
        aÃ§Ã£o: 'ReuniÃ£o emergencial com stakeholders',
        prazo: 'Hoje',
        responsÃ¡vel: 'Sponsor do Projeto',
      });
    }

    // AÃ§Ãµes de melhoria contÃ­nua
    aÃ§Ãµes.push({
      prioridade: 'mÃ©dia',
      aÃ§Ã£o: 'Implementar dashboard de acompanhamento em tempo real',
      prazo: '3 dias',
      responsÃ¡vel: 'Equipe de TI',
    });

    return aÃ§Ãµes;
  }

  private getPrioridadeNumerica(impacto: 'alto' | 'mÃ©dio' | 'baixo'): number {
    switch (impacto) {
      case 'alto':
        return 1;
      case 'mÃ©dio':
        return 2;
      case 'baixo':
        return 3;
      default:
        return 4;
    }
  }
}
